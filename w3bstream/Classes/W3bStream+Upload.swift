import Foundation

public extension W3bStream {
    
    
    /// make the https upload payload
    /// - Parameters:
    ///   - info: json string
    /// - Returns: description
    static func makePayload(info: String) -> [String: Any]? {

        guard let jsonData = info.data(using: .utf8) else {
            return nil
        }

        guard let _signature = sign(jsonData) else {
            return nil
        }
        
        guard let signature = MFKeychainHelper.ABIEncoding(_signature) else {
            return nil
        }
        
        guard let key = MFKeychainHelper.loadKey(name: MFKeychainHelper.PrivateKeyName) else {
            print("load key failed")
            return nil
        }
        guard let pubKey = MFKeychainHelper.getPubKey(key) else {
            return [:]
        }
        let compressPubKey = MFKeychainHelper.compressedPubKey(pubKey)
        
        return ["data": info,
                "pubKey": "\(compressPubKey)",
                "signature": "\(signature.toHexString().addHexPrefix())"
               ]
        
    }
    


    static func makeWebsocketPayload(tag: Int?=nil, payload: [String: Any]) -> [String:Any]? {
        let dic = ["id": tag ?? 10,
                   "jsonrpc": "2.0",
                   "method": "mutation",
                   "params": [
                        "input": payload,
                        "path": "data"
                    ]
        ] as [String : Any]
        return dic
    }
    
    
    /// upload the data using https. the independent method
    /// - Parameters:
    ///   - url: url
    ///   - payload: generated by makePayload
    ///   - completionHandler:
    internal func uploadViaHttps(url: URL, payload: [String: Any],
                                 headers: [String: String] = [:],
                                 completionHandler: @escaping (Data?, URLResponse?, Error?) -> Void) {
        let jsonData = try? JSONSerialization.data(withJSONObject: payload)
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        
        headers.forEach { (key, value) in
            request.addValue(value, forHTTPHeaderField: key)
        }
        request.httpBody = jsonData
//        print("payload \(payload)")
//        print("headers = \(request.allHTTPHeaderFields)")
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            completionHandler(data, response, error)
        }
        task.resume()
        
    }
        
    /// upload the data using Websocket. the independent method
    /// - Parameters:
    ///   - url: url
    ///   - payload: generated by makeWebsocketPayload
    ///   - completionHandler:
    private func uploadViaWebsocket(payload: [String: Any]) {
        if let jsonData = try? JSONSerialization.data(withJSONObject: payload) {
            WebSocketManager.shared.writeData(jsonData)
        }
    }
    
    
    /// upload the data timely, chose to use https and websocket automatically
    /// - Parameters:
    ///   - httpsCompletionHandler:
    ///   - websocketCompletionHandler:
    ///   - tag: the unique tag binds with the data,  you can get the tag from the completionHandler
    func upload(data: String, tag: Int?=nil, completionHandler: ((Int?, URL?, Data?, Error?) -> Void)?) {
        guard let payload = W3bStream.makePayload(info: data) else {
            return
        }
        if Config.shared.httpsUrls.count > 0 {
            Config.shared.httpsUrls.forEach { url in
                self.uploadViaHttps(url: url,payload: payload) { data, res, err in
                    completionHandler?(tag, res?.url, data, err)
                }
            }
        }
            
        if Config.shared.websocketUrls.count > 0 {
            if self.w3bWebsocketDidReceiveData == nil {
                self.w3bWebsocketDidReceiveData = completionHandler
            }
            guard let payload = W3bStream.makeWebsocketPayload(tag: tag, payload: payload) else {
                return
            }
            Config.shared.websocketUrls.forEach { _ in
                self.uploadViaWebsocket(payload: payload)
            }
        }
    }
    
    

    
    /// stop the websocket disconnect
    func stopWebsocket() {
        WebSocketManager.shared.disconnectAll()
    }
    

}

